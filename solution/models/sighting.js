/**
 * @description Module to model the sightings collection in the sightings database.
 * @type {{disconnect: {(): Promise<void>, (cb: CallbackWithoutResult): void}, SchemaTypeOptions: SchemaTypeOptions, Query: Query, ToObjectOptions: ToObjectOptions, pathsToValidate: string[] | string, Document: Document, LegacyAsyncValidateFn: LegacyAsyncValidateFn, DocumentQuery: Query<ResultType, DocType, THelpers>, PopulateOptions: PopulateOptions, mquery: mquery, IndexDefinition: IndexDefinition, IndexesDiff: IndexesDiff, ErrorHandlingMiddlewareFunction: (this:ThisType, err: NativeError, res: ResType, next: (err?: CallbackError) => void) => void, AnyKeys: AnyKeys, ExtractMethods: M extends Model<any, any, infer TMethods> ? TMethods : {}, SchemaDefinitionProperty: T extends (string | number | boolean | NativeDate | Function) ? (SchemaDefinitionWithBuiltInClass<T> | SchemaTypeOptions<T>) : (SchemaTypeOptions<T extends undefined ? any : T> | typeof SchemaType | Schema<any, any, any, any> | Schema<any, any, any, any>[] | ReadonlyArray<Schema<any, any, any, any>> | SchemaTypeOptions<T extends undefined ? any : T>[] | ReadonlyArray<SchemaTypeOptions<T extends undefined ? any : T>> | Function[] | SchemaDefinition<T> | SchemaDefinition<T>[] | ReadonlyArray<SchemaDefinition<T>>), model: {<T>(name: string, schema?: Schema<any>, collection?: string, skipInit?: boolean): Model<T>, <T, U extends Model<T, TQueryHelpers, any>, TQueryHelpers={}>(name: string, schema?: Schema<T, U, TQueryHelpers>, collection?: string, skipInit?: boolean): U, <T, U extends Model<T, TQueryHelpers, any>, TQueryHelpers={}>(name: string, schema?: Schema<any>, collection?: string, skipInit?: boolean): U}, connection: Connection, deleteModel(name: (string | RegExp)): typeof mongoose, QueryCursor: QueryCursor, __UpdateDefProperty: 0 extends (1 & T) ? T : (T extends unknown[] ? LeanArray<T> : (T extends Document ? LeanDocument<T> : ([Extract<T, ObjectId>] extends [never] ? T : (string | T)))), modelNames(): Array<string>, models: {[p: string]: Model<any>}, SchemaPreOptions: SchemaPreOptions, Unpacked: T extends infer U[] ? U : T, UpdateQuery: _UpdateQuery<_UpdateQueryDef<T>> & ReadonlyPartial<_UpdateQueryDef<LeanDocument<T>>> & DotAndArrayNotation<any>, AggregationCursor: AggregationCursor, ConnectionStates: module:mongoose.ConnectionStates, version: string, __UpdateQueryDef: __UpdateQueryDef, InsertManyResult: InsertManyResult, Promise: any, ValidatorMessageFn: ValidatorMessageFn, PopulatedDoc: PopulatedType | RawId, actualPrimitives: string | boolean | number | bigint | symbol, _UpdateQueryDef: _UpdateQueryDef, IndexDirection: 1 | -1 | "2d" | "2dsphere" | "geoHaystack" | "hashed" | "text", isValidObjectId(v: any): boolean, TreatAsPrimitives: string | boolean | number | bigint | symbol | NativeDate | RegExp | Error | BigInt | Types.ObjectId, SchemaTimestampsConfig: SchemaTimestampsConfig, AcceptsDiscriminator: AcceptsDiscriminator, NativeError: NativeError, ValidateOpts: ValidateOpts, pathsToSkip: string[] | string, OnlyFieldsOfType: OnlyFieldsOfType, VirtualTypeOptions: VirtualTypeOptions, SchemaPostOptions: SchemaPostOptions, NativeDate: NativeDate, TagSet: TagSet, get<K extends keyof MongooseOptions>(key: K): MongooseOptions[K], ConnectionOptions: ConnectOptions, SaveOptions: SaveOptions, PreSaveMiddlewareFunction: (this:T, next: (err?: CallbackError) => void, opts: SaveOptions) => (void | Promise<void>), connect: {(uri: string, options: ConnectOptions, callback: CallbackWithoutResult): void, (uri: string, callback: CallbackWithoutResult): void, (uri: string, options?: ConnectOptions): Promise<Mongoose>}, SchemaDefinition: T extends undefined ? {[p: string]: SchemaDefinitionProperty} : {[path in keyof T]?: SchemaDefinitionProperty<T[path]>}, STATES: module:mongoose.ConnectionStates, set<K extends keyof MongooseOptions>(key: K, value: MongooseOptions[K]): typeof mongoose, IndexOptions: IndexOptions, UpdateWriteOpResult: UpdateWriteOpResult, DocumentDefinition: DocumentDefinition, CollectionBase: CollectionBase, Connection: Connection, createConnection: {(uri: string, options?: ConnectOptions): (Connection & Promise<Connection>), (): Connection, (uri: string, options: ConnectOptions, callback: Callback<Connection>): void}, pluralize(fn?: (((str: string) => string) | null)): (((str: string) => string) | null), MapReduceOptions: MapReduceOptions, AnyObject: AnyObject, CastError: Error.CastError, HookDoneFunction: HookDoneFunction, plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): typeof mongoose, MongooseOptions: MongooseOptions, Model: Model<any>, Aggregate: Aggregate, Types: Types, MongooseQueryMiddleware: "count" | "deleteMany" | "deleteOne" | "distinct" | "find" | "findOne" | "findOneAndDelete" | "findOneAndRemove" | "findOneAndUpdate" | "remove" | "update" | "updateOne" | "updateMany", HookSyncCallback: HookSyncCallback, LeanDocumentOrArrayWithRawType: 0 extends (1 & T) ? T : (T extends unknown[] ? RawDocType[] : (T extends Document ? RawDocType : T)), Schema: Schema, FilterQuery: {[P in keyof T]?: Condition<[Extract<T[P], ObjectId>] extends [never] ? T[P] : (T[P] | string)>} & RootQuerySelector<T>, LeanType: 0 extends (1 & T) ? T : (T extends TreatAsPrimitives ? T : LeanDocument<T>), VirtualType: VirtualType, QueryOptions: QueryOptions, SchemaType: SchemaType, Mongoose: {new(options?: (MongooseOptions | null)): typeof mongoose}, RefType: number | string | Buffer | mongoose.Types.ObjectId | mongoose.Types.Buffer | Number | String | Buffer | ObjectId, LeanDocumentOrArray: 0 extends (1 & T) ? T : (T extends unknown[] ? LeanDocument<T[number]>[] : (T extends Document ? LeanDocument<T> : T)), LeanArray: T extends unknown[][] ? LeanArray<T[number]>[] : LeanType<T[number]>[], CallbackError: NativeError, _UpdateWriteOpResult: _UpdateWriteOpResult, startSession: {(options?: SessionOptions): Promise<ClientSession>, (options: SessionOptions, cb: Callback<ClientSession>): void}, LeanDocumentElement: 0 extends (1 & T) ? T : (T extends unknown[] ? LeanArray<T> : (T extends Document ? LeanDocument<T> : T)), PromiseProvider: any, connections: Connection[], InsertManyOptions: InsertManyOptions, MongooseQueryOptions: MongooseQueryOptions, ValidateFn: ValidateFn, _LeanDocument: _LeanDocument, LeanDocument: LeanDocument, ModelUpdateOptions: QueryOptions, SchemaTypes: {Array: Array, Boolean: Boolean, Buffer: Buffer, Date: Date, Decimal128: Decimal128, DocumentArray: DocumentArray, Map: Map, Mixed: Mixed, Number: Number, ObjectId: ObjectId, Embedded: Embedded, String: String}, AnyArray: T[] | ReadonlyArray<T>, Mixed: Schema.Types.Mixed, CallbackWithoutResult: (error: CallbackError) => void, SchemaDefinitionWithBuiltInClass: T extends number ? (typeof Number | "number" | "Number" | typeof Schema.Types.Number) : (T extends string ? (typeof String | "string" | "String" | typeof Schema.Types.String) : (T extends boolean ? (typeof Boolean | "boolean" | "Boolean" | typeof Schema.Types.Boolean) : (T extends NativeDate ? (typeof NativeDate | "date" | "Date" | typeof Schema.Types.Date) : (Function | string)))), Collection: Collection, ReturnsNewDoc: {new: true} | {returnOriginal: false} | {returnDocument: "after"}, AsyncValidateFn: AsyncValidateFn, mongo: {BulkWriteDeleteOperation: BulkWriteDeleteOperation, CollationDocument: CollationDocument, SetFields: {readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?: UpdateOptionalId<Unpacked<TSchema[key]>> | AddToSetOperators<Array<UpdateOptionalId<Unpacked<TSchema[key]>>>>} & NotAcceptedFields<TSchema, ReadonlyArray<any>> & {[p: string]: any}, ProfilingLevel: "off" | "slow_only" | "all", GridFSBucketWriteStream: GridFSBucketWriteStream, ClientSession: ClientSession, PushOperator: {readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Unpacked<TSchema[key]> | ArrayOperator<Array<Unpacked<TSchema[key]>>>} & NotAcceptedFields<TSchema, ReadonlyArray<any>> & {[p: string]: any}, Int32: any, DeleteWriteOpResultObject: DeleteWriteOpResultObject, MapReduceOptions: MapReduceOptions, WithoutProjection: T & {fields?: undefined, projection?: undefined}, AddUserOptions: AddUserOptions, Long: any, MongosOptions: MongosOptions, ChangeEventInvalidate: ChangeEventInvalidate, IndexSpecification: IndexSpecification, GridFSBucketWriteStreamOptions: GridFSBucketWriteStreamOptions, ChangeEventTypes: "insert" | "delete" | "replace" | "update" | "drop" | "rename" | "dropDatabase" | "invalidate", ReadPreferenceMode: "primary" | "primaryPreferred" | "secondary" | "secondaryPreferred" | "nearest", CollectionBulkWriteOptions: CollectionBulkWriteOptions, ReadPreferenceOrMode: ReadPreference | "primary" | "primaryPreferred" | "secondary" | "secondaryPreferred" | "nearest", UpdateQuery: UpdateQuery, CollStats: CollStats, IndexOptions: IndexOptions, BulkWriteResultUpsertedIdObject: BulkWriteResultUpsertedIdObject, BulkWriteUpdateOperation: BulkWriteUpdateOperation, BSONType: BSONType, DbAddUserOptions: DbAddUserOptions, ReadPreferenceOptions: ReadPreferenceOptions, GridFSBucketOptions: GridFSBucketOptions, ChangeEventRename: ChangeEventRename, BulkWriteOpResultObject: BulkWriteOpResultObject, FindOneOptions: FindOneOptions, QuerySelector: QuerySelector, DbCreateOptions: DbCreateOptions, OnlyFieldsOfType: AcceptedFields<TSchema, FieldType, AssignableType> & NotAcceptedFields<TSchema, FieldType> & DotAndArrayNotation<AssignableType>, GridFSBucketReadStream: GridFSBucketReadStream, FindOneAndUpdateOption: FindOneAndUpdateOption, IteratorCallback: IteratorCallback, MongoError: MongoError, InsertWriteOpResult: InsertWriteOpResult, CommandCursorResult: object, KMSProviders: KMSProviders, GridFSBucketOpenUploadStreamOptions: GridFSBucketOpenUploadStreamOptions, GridFSBucket: GridFSBucket, MongoClientCommonOption: MongoClientCommonOption, AggregationCursor: AggregationCursor, ResumeToken: ResumeToken, ReadPreference: ReadPreference, HighAvailabilityOptions: HighAvailabilityOptions, ReplaceOneOptions: ReplaceOneOptions, Decimal128: any, UpdateOneOptions: UpdateOneOptions, PullOperator: {readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Partial<Unpacked<TSchema[key]>> | ObjectQuerySelector<Unpacked<TSchema[key]>>} & NotAcceptedFields<TSchema, ReadonlyArray<any>> & {[p: string]: any}, ClientSessionId: unknown, UnorderedBulkOperation: UnorderedBulkOperation, FindAndModifyWriteOpResultObject: FindAndModifyWriteOpResultObject, ProjectionOperators: ProjectionOperators, UnifiedTopologyOptions: UnifiedTopologyOptions, MongoParseError: MongoParseError, BulkWriteUpdateOneOperation: BulkWriteUpdateOneOperation, MongoClientOptions: MongoClientOptions, Condition: T extends ReadonlyArray<infer U> ? (RegExpForString<U> | T) : RegExpForString<T> | QuerySelector<T extends ReadonlyArray<infer U> ? (RegExpForString<U> | T) : RegExpForString<T>>, ChangeEventDelete: ChangeEventDelete, BulkWriteUpdateManyOperation: BulkWriteUpdateManyOperation, MongoClient: MongoClient, BulkWriteOperation: BulkWriteInsertOneOperation<TSchema> | BulkWriteUpdateOneOperation<TSchema> | BulkWriteUpdateManyOperation<TSchema> | BulkWriteReplaceOneOperation<TSchema> | BulkWriteDeleteOneOperation<TSchema> | BulkWriteDeleteManyOperation<TSchema>, Logger: Logger, LoggerOptions: LoggerOptions, EndCallback: EndCallback, ReplSet: ReplSet, MinKey: any, BulkWriteResult: BulkWriteResult, UpdateManyOptions: UpdateManyOptions, ChangeEventUpdate: ChangeEventUpdate, ChangeEvent: ChangeEventCR<TSchema> | ChangeEventUpdate<TSchema> | ChangeEventDelete<TSchema> | ChangeEventRename<TSchema> | ChangeEventOther<TSchema> | ChangeEventInvalidate<TSchema>, WriteError: WriteError, BulkWriteDeleteOneOperation: BulkWriteDeleteOneOperation, MatchKeysAndValues: ReadonlyPartial<TSchema> & DotAndArrayNotation<any>, LoggerState: LoggerState, OptionalId: ObjectId extends TSchema["_id"] ? (EnhancedOmit<TSchema, "_id"> & {_id?: ExtractIdType<TSchema> | undefined}) : WithId<TSchema>, ReadPreferenceTags: ReadonlyArray<Record<string, string>>, FindOperators: FindOperators, BulkWriteInsertOneOperation: BulkWriteInsertOneOperation, DBRef: any, MongoWriteConcernError: MongoWriteConcernError, FilterQuery: {[P in keyof T]?: Condition<T[P]>} & RootQuerySelector<T>, TLSOptions: TLSOptions, WithId: string | number extends keyof TSchema ? TSchema : (TSchema extends any ? Pick<TSchema, Exclude<keyof TSchema, "_id">> : never) & {_id: ExtractIdType<TSchema>}, Admin: Admin, log: (message?: string, state?: LoggerState) => void, SortValues: -1 | 1, connect: {(uri: string, options?: MongoClientOptions): Promise<MongoClient>, (uri: string, callback: MongoCallback<MongoClient>): void, (uri: string, options: MongoClientOptions, callback: MongoCallback<MongoClient>): void}, AutoEncryptionExtraOptions: AutoEncryptionExtraOptions, ObjectId: any, ChangeStream: ChangeStream, GridFSBucketErrorCallback: GridFSBucketErrorCallback, MongoCountPreferences: MongoCountPreferences, ChangeEventOther: ChangeEventOther, SocketOptions: SocketOptions, MetaProjectionOperators: "textScore" | "indexKey" | "searchScore" | "searchHighlights", CommonOptions: CommonOptions, MongoTimeoutError: MongoTimeoutError, OrderedBulkOperation: OrderedBulkOperation, FindOneAndDeleteOption: FindOneAndDeleteOption, WriteConcernError: WriteConcernError, MongoCallback: MongoCallback, CollectionMapFunction: (this:TSchema) => void, FindOneAndReplaceOption: FindOneAndReplaceOption, GridFSBucketFindOptions: GridFSBucketFindOptions, GridFSBucketReadStreamOptions: GridFSBucketReadStreamOptions, Collection: Collection, SSLOptions: SSLOptions, ChangeEventCR: ChangeEventCR, CursorResult: object | boolean, MetaSortOperators: "textScore" | "indexKey", AutoEncryptionOptions: AutoEncryptionOptions, Double: any, Binary: any, Code: Code, GeoHaystackSearchOptions: GeoHaystackSearchOptions, SessionOptions: SessionOptions, ArrayOperator: ArrayOperator, CollectionReduceFunction: (key: TKey, values: TValue[]) => TValue, AggregationCursorResult: object, WriteOpResult: WriteOpResult, Timestamp: any, Mongos: Mongos, TransactionOptions: TransactionOptions, MaxKey: any, CollectionAggregationOptions: CollectionAggregationOptions, MongoBulkWriteError: BulkWriteError, FSyncOptions: FSyncOptions, CollectionCreateOptions: CollectionCreateOptions, ReplaceWriteOpResult: ReplaceWriteOpResult, PullAllOperator: {readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key]} & NotAcceptedFields<TSchema, ReadonlyArray<any>> & {[p: string]: any[]}, ParallelCollectionScanOptions: ParallelCollectionScanOptions, ChangeEventBase: ChangeEventBase, MongoNetworkError: MongoNetworkError, CollectionInsertOneOptions: CollectionInsertOneOptions, Cursor: Cursor, ChangeStreamOptions: ChangeStreamOptions, WithTransactionCallback: (session: ClientSession) => Promise<void>, SchemaMember: {[P in keyof T]?: V} | {[p: string]: V}, ObjectID: any, UpdateWriteOpResult: UpdateWriteOpResult, Server: Server, ReadConcern: ReadConcern, BulkWriteReplaceOneOperation: BulkWriteReplaceOneOperation, ObjectQuerySelector: T extends object ? {[key in keyof T]?: QuerySelector<T[key]>} : QuerySelector<T>, Db: Db, MongoDistinctPreferences: MongoDistinctPreferences, SortOptionObject: {[P in keyof T]?: number | {$meta?: MetaSortOperators | undefined}} | {[p: string]: number | {$meta?: MetaSortOperators | undefined}}, DbCollectionOptions: DbCollectionOptions, CursorCommentOptions: CursorCommentOptions, CommandCursor: CommandCursor, ReplSetOptions: ReplSetOptions, RootQuerySelector: RootQuerySelector, WiredTigerData: WiredTigerData, CollectionInsertManyOptions: CollectionInsertManyOptions, BulkWriteError: BulkWriteError, MongoServerSelectionError: MongoServerSelectionError, AddToSetOperators: AddToSetOperators, ServerOptions: ServerOptions, BulkWriteDeleteManyOperation: BulkWriteDeleteManyOperation, InsertOneWriteOpResult: InsertOneWriteOpResult}, ExtractQueryHelpers: M extends Model<any, infer TQueryHelpers> ? TQueryHelpers : {}, _UpdateQuery: _UpdateQuery, QueryWithHelpers: Query<ResultType, DocType, THelpers, RawDocType> & THelpers, HookNextFunction: HookNextFunction, _FilterQuery: {[P in keyof T]?: Condition<[Extract<T[P], ObjectId>] extends [never] ? T[P] : (T[P] | string)>} & RootQuerySelector<T>, Number: Number, ClientSession: ClientSession, now(): NativeDate, SchemaOptions: SchemaOptions, ConnectOptions: ConnectOptions, ValidatorProps: ValidatorProps, PreMiddlewareFunction: (this:T, next: (err?: CallbackError) => void) => (void | Promise<void>), EnforceDocument: T extends Document ? T : (T & Document<any, any, T> & TMethods), ObjectId: Schema.Types.ObjectId, GeoSearchOptions: GeoSearchOptions, Error: Error, NumericTypes: number | Decimal128 | Double | Int32 | Long, Decimal128: Schema.Types.Decimal128, HookErrorCallback: HookErrorCallback, MongooseDocumentMiddleware: "validate" | "save" | "remove" | "updateOne" | "deleteOne" | "init", SchemaTypeOpts: SchemaTypeOptions<T>, Date: Schema.Types.Date, Callback: (error: CallbackError, result: T) => void, WriteConcern: WriteConcern, PostMiddlewareFunction: (this:ThisType, res: ResType, next: (err?: CallbackError) => void) => (void | Promise<void>), UpdateWithAggregationPipeline: UpdateAggregationStage[], HookAsyncCallback: HookAsyncCallback, UpdateAggregationStage: {$addFields: any} | {$set: any} | {$project: any} | {$unset: any} | {$replaceRoot: any} | {$replaceWith: any}}}
 */

// Require the Mongoose library
var mongoose = require('mongoose');

// Get the Schema object from Mongoose
var Schema = mongoose.Schema;

// Create a new Schema for the Sighting model
var SightingSchema = new Schema({
    // Define the fields for the Sighting model
    uploadedBy: { type: String },       // Username of the user who uploaded the sighting
    identification: { type: String },   // Identification of the sighting
    description: { type: String },      // Description of the sighting
    dateTime: { type: Date },           // Date and time of the sighting
    latitude: { type: Number },         // Latitude coordinate of the sighting location
    longitude: { type: Number },        // Longitude coordinate of the sighting location
    img: { type: String },              // Image associated with the sighting
    signature: { type: String }         // Signature of the sighting
});

// Set options for the SightingSchema
SightingSchema.set('toObject', { getters: true, virtuals: true });

// Create a model using the SightingSchema
var Sighting = mongoose.model('Sighting', SightingSchema);

// Export the Sighting model to make it available in other parts of the application
module.exports = Sighting;
